#!/usr/bin/env python3
"""Add detailed explanations for Q31-90"""
import json,os
SD = os.path.dirname(os.path.abspath(__file__))
D = {}
D[31]=["❌ جزئياً - إدارة العمليات إحدى الوظائف فقط.","❌ جزئياً - إدارة الذاكرة إحدى الوظائف فقط.","❌ خاطئ. تنفيذ المترجم ليس وظيفة نظام التشغيل بل هو برنامج تطبيقي.","✅ صحيح! إدارة العمليات والذاكرة من وظائف نظام التشغيل (ملاحظة: تنفيذ المترجم ليس وظيفة نظام تشغيل لكن الجواب حسب البنك)."]
D[32]=["❌ خاطئ. الصَدَفة (Shell) هي واجهة المستخدم وليست الجزء الأساسي.","✅ صحيح! النواة (Kernel) هي الجزء الأساسي في نظام التشغيل وتتحكم بجميع الموارد.","❌ خاطئ. CLI واجهة نصية وليست الجزء الأساسي.","❌ خاطئ. برنامج التعريف يتحكم بجهاز معين فقط."]
D[33]=["❌ خاطئ. Windows 10 نظام تشغيل للأغراض العامة.","❌ خاطئ. Linux Ubuntu للأغراض العامة أيضاً.","✅ صحيح! RTOS مصمم خصيصاً للتطبيقات التي تحتاج استجابة فورية ومحددة زمنياً.","❌ خاطئ. macOS نظام للأغراض العامة."]
D[34]=["❌ خاطئ. الترجمة من وظائف المترجم (Compiler) وليس نظام التشغيل.","✅ صحيح! الوظيفة الرئيسية لنظام التشغيل هي إدارة موارد العتاد والبرمجيات.","❌ خاطئ. تحرير المستندات وظيفة التطبيقات.","❌ خاطئ. تشغيل مضاد الفيروسات وظيفة تطبيقية."]
D[35]=["❌ خاطئ. Round Robin تعطي كل عملية شريحة زمنية ثابتة. يكون صحيحاً عند السؤال عن Time Quantum.","❌ خاطئ. SJN تنفذ الأقصر أولاً وليس الأول وصولاً.","✅ صحيح! FCFS (أولاً يأتي أولاً يُخدم) تنفذ العمليات حسب ترتيب وصولها.","❌ خاطئ. Priority Scheduling تعتمد على الأولوية وليس ترتيب الوصول."]
D[36]=["✅ صحيح! الترحيل (Paging) يقسم الذاكرة إلى إطارات (Frames) ثابتة الحجم والبرنامج إلى صفحات (Pages) بنفس الحجم.","❌ خاطئ. التقسيم (Segmentation) يقسم الذاكرة إلى أجزاء متفاوتة الحجم حسب المنطق.","❌ خاطئ. التخصيص المتجاور يعطي كتلة واحدة متصلة.","❌ خاطئ. التبديل (Swapping) ينقل عمليات بين الذاكرة والقرص."]
D[37]=["✅ صحيح! PCB تحتوي على معرف العملية (PID)، عداد البرنامج (PC)، حالة العملية، والسجلات وغيرها.","❌ خاطئ. PCB تحتوي على أكثر من مجرد معرف العملية.","❌ خاطئ. PCB تحتوي على أكثر من تفاصيل الذاكرة فقط.","❌ خاطئ. PCB خاصة بعملية واحدة وليست قائمة بجميع العمليات."]
D[38]=["❌ خاطئ. التحكم في العمليات نوع فعلي من استدعاءات النظام (fork, exit, wait).","❌ خاطئ. إدارة الذاكرة نوع فعلي من استدعاءات النظام.","❌ خاطئ. التعامل مع الملفات نوع فعلي (open, read, write, close).","✅ صحيح! تصفح الويب ليس نوعاً من استدعاءات النظام بل هو تطبيق مستخدم."]
D[39]=["❌ خاطئ. انخفاض استغلال المعالج قد يكون نتيجة للتخبط وليس سببه.","✅ صحيح! التخبط (Thrashing) يحدث بسبب الترحيل المفرط - النظام يقضي وقتاً أكثر في تبديل الصفحات من التنفيذ الفعلي.","❌ خاطئ. الجدولة منخفضة الأولوية لا تسبب تخبطاً.","❌ خاطئ. الشريحة الزمنية الكبيرة لا تسبب تخبطاً."]
D[40]=["✅ صحيح! fork() في UNIX ينشئ عملية جديدة (عملية ابن) نسخة من العملية الأب.","❌ خاطئ. لإنهاء عملية نستخدم exit() أو kill(). يكون صحيحاً عند السؤال عنهما.","❌ خاطئ. لتخصيص الذاكرة نستخدم malloc() أو brk().","❌ خاطئ. للتبديل بين العمليات يستخدم المجدول Context Switch."]
D[41]=["✅ صحيح! نظام التشغيل هو مجموعة برمجيات تدير موارد العتاد وتوفر خدمات للمستخدم والتطبيقات.","❌ خاطئ. نظام التشغيل برمجية وليس مكوناً مادياً.","❌ خاطئ. نظام التشغيل ليس لغة برمجة بل نظام يدير الموارد.","❌ خاطئ. نظام إدارة قواعد البيانات (DBMS) برنامج مختلف تماماً."]
D[42]=["❌ خاطئ. Microsoft Word تطبيق معالجة نصوص.","✅ صحيح! Windows 10 نظام تشغيل للحواسيب الشخصية من Microsoft.","❌ خاطئ. Google Chrome متصفح ويب وليس نظام تشغيل.","❌ خاطئ. Python لغة برمجة وليست نظام تشغيل."]
D[43]=["❌ خاطئ. الصدفة (Shell) واجهة بين المستخدم ونظام التشغيل ولا تتفاعل مباشرة مع العتاد.","❌ خاطئ. البرامج التطبيقية تعمل فوق نظام التشغيل.","✅ صحيح! النواة (Kernel) هي المكون الذي يتفاعل مباشرة مع العتاد ويدير الموارد.","❌ خاطئ. نظام الملفات ينظم البيانات على القرص لكنه لا يتفاعل مباشرة مع كل العتاد."]
D[44]=["❌ خاطئ. إدارة الذاكرة وظيفة أساسية لنظام التشغيل.","❌ خاطئ. إدارة العمليات وظيفة أساسية لنظام التشغيل.","✅ صحيح! ترجمة البرامج (Compiling) ليست وظيفة نظام التشغيل بل وظيفة المترجم (Compiler) وهو برنامج منفصل.","❌ خاطئ. إدارة نظام الملفات وظيفة أساسية لنظام التشغيل."]
D[45]=["❌ خاطئ. نظام المشاركة الزمنية يهدف لمشاركة المعالج بين عدة مستخدمين.","❌ خاطئ. النظام الموزع يوزع المهام على عدة حواسيب.","✅ صحيح! نظام الوقت الحقيقي (Real-Time OS) مصمم لتطبيقات تحتاج استجابة محددة زمنياً كأنظمة التحكم الصناعي.","❌ خاطئ. نظام الدُفعات (Batch OS) ينفذ المهام بالتتابع بدون تفاعل."]
D[46]=["✅ صحيح! البرمجة المتعددة (Multiprogramming) تزيد استغلال المعالج بتشغيل عدة برامج حيث ينتقل المعالج لبرنامج آخر عند انتظار I/O.","❌ خاطئ. البرمجة المتعددة تزيد عدد العمليات في الذاكرة.","❌ خاطئ. البرمجة المتعددة تحتاج ذاكرة أكثر لتحميل عدة برامج.","❌ خاطئ. تحسين وقت تنفيذ عملية واحدة ليس هدف البرمجة المتعددة."]
D[47]=["✅ صحيح! الهدف الأساسي لنظام المشاركة الزمنية هو تقليل وقت الاستجابة بإعطاء كل مستخدم شريحة زمنية من المعالج.","❌ خاطئ. تعظيم استغلال المعالج هدف البرمجة المتعددة أكثر.","❌ خاطئ. زيادة أولوية العمليات ليس هدف المشاركة الزمنية.","❌ خاطئ. منع تجزئة الذاكرة ليس هدف المشاركة الزمنية."]
D[48]=["❌ خاطئ. نظام المستخدم الواحد يسمح لمستخدم واحد فقط.","✅ صحيح! نظام متعدد المستخدمين (Multi-User OS) يسمح لعدة مستخدمين بالعمل على النظام في نفس الوقت.","❌ خاطئ. Real-Time OS مصمم للاستجابة الفورية وليس بالضرورة متعدد المستخدمين.","❌ خاطئ. النظام المدمج (Embedded OS) مخصص لأجهزة محددة."]
D[49]=["❌ خاطئ. إدارة جدولة المعالج من وظائف المجدول.","✅ صحيح! برنامج تعريف الجهاز (Device Driver) يتحكم في أجهزة العتاد ويوفر واجهة بين نظام التشغيل والجهاز.","❌ خاطئ. تنظيم الملفات والأدلة من وظائف نظام الملفات.","❌ خاطئ. تخصيص الذاكرة من وظائف مدير الذاكرة."]
D[50]=["❌ خاطئ. Windows 11 نظام مملوك لـ Microsoft.","❌ خاطئ. macOS نظام مملوك لـ Apple.","✅ صحيح! Linux نظام تشغيل مفتوح المصدر يمكن لأي شخص استخدامه وتعديله وتوزيعه مجاناً.","❌ خاطئ. iOS نظام مملوك لـ Apple."]
D[51]=["❌ خاطئ. نظام الدفعات (Batch OS) نوع فعلي من أنظمة التشغيل.","❌ خاطئ. نظام الوقت الحقيقي نوع فعلي.","❌ خاطئ. نظام الشبكات (Network OS) نوع فعلي.","✅ صحيح! لا يوجد شيء اسمه Compiler OS - المترجم برنامج وليس نوع نظام تشغيل."]
D[52]=["❌ خاطئ. نظام الملفات ينظم الملفات على القرص.","❌ خاطئ. مدير الذاكرة يدير تخصيص الذاكرة.","✅ صحيح! مجدول العمليات (Process Scheduler) مسؤول عن تحديد أي عملية تُنفذ ومتى.","❌ خاطئ. برنامج التعريف يتحكم بجهاز معين."]
D[53]=["❌ خاطئ. مساحة الذاكرة الكبيرة ليست هدف جدولة المشاركة الزمنية.","✅ صحيح! في نظام المشاركة الزمنية، تتم الجدولة لتوفير وقت استجابة سريع للمستخدمين.","❌ خاطئ. الإنتاجية العالية هدف لكنها ليست الهدف الرئيسي للمشاركة الزمنية.","❌ خاطئ. استهلاك الطاقة المنخفض ليس هدف هذا النوع."]
D[54]=["❌ خاطئ. Linux مبني على معمارية UNIX (نواة مشابهة).","✅ صحيح! Windows ليس مبنياً على UNIX بل له معمارية خاصة (NT Kernel).","❌ خاطئ. macOS مبني على Darwin وهو مبني على UNIX (BSD).","❌ خاطئ. Android مبني على نواة Linux المشابهة لـ UNIX."]
D[55]=["✅ صحيح! مجدول العمليات (Process Scheduler) هو المكون المسؤول عن إدارة العمليات وجدولتها.","❌ خاطئ. CLI واجهة لتلقي أوامر المستخدم وليست لإدارة العمليات.","❌ خاطئ. المجمّع (Assembler) يحول لغة التجميع لكود الآلة.","❌ خاطئ. الرابط (Linker) يربط ملفات الكود المترجمة معاً."]
D[56]=["❌ خاطئ. MS-DOS نظام مستخدم واحد.","❌ خاطئ. Windows XP يدعم مستخدمين لكنه ليس متعدد المستخدمين بالمعنى التقليدي.","✅ صحيح! UNIX نظام تشغيل متعدد المستخدمين يسمح لعدة مستخدمين بالعمل في نفس الوقت عبر طرفيات مختلفة.","❌ خاطئ. Android مصمم لمستخدم واحد على الجهاز."]
D[57]=["❌ خاطئ. المقاطعة لا تزيد سرعة المعالج.","✅ صحيح! المقاطعة (Interrupt) تُستخدم لإعلام المعالج بأحداث مثل اكتمال عملية إدخال/إخراج أو طلب من جهاز.","❌ خاطئ. المقاطعة لا تحسن وقت الوصول للقرص مباشرة.","❌ خاطئ. تخصيص الذاكرة الديناميكي ليس من وظائف المقاطعة."]
D[58]=["❌ خاطئ. الافتراضية (Virtualization) تشغيل عدة أنظمة على نفس العتاد وليس مجرد عدة برامج.","✅ صحيح! البرمجة المتعددة (Multiprogramming) تسمح بتشغيل عدة برامج في نفس الوقت عبر تبديل المعالج بينها.","❌ خاطئ. التنقيح (Debugging) عملية إصلاح الأخطاء في البرامج.","❌ خاطئ. التشفير (Encryption) حماية البيانات وليس تشغيل عدة برامج."]
D[59]=["❌ خاطئ. النواة تتفاعل مع العتاد وليس المستخدم مباشرة.","✅ صحيح! الصدفة (Shell) هي الجزء الذي يتفاعل مع المستخدم سواء كانت نصية (CLI) أو رسومية (GUI).","❌ خاطئ. مدير الذاكرة يعمل في الخلفية ولا يتفاعل مع المستخدم.","❌ خاطئ. جدول العمليات بنية بيانات داخلية."]
D[60]=["✅ صحيح! محمل الإقلاع (Bootloader) مسؤول عن تحميل نظام التشغيل في الذاكرة عند تشغيل الحاسوب.","❌ خاطئ. إدارة العمليات تبدأ بعد تحميل النظام.","❌ خاطئ. معالجة أوامر المستخدم من وظائف الصدفة.","❌ خاطئ. التحكم في نظام الملفات يبدأ بعد الإقلاع."]
D[61]=["✅ صحيح! العملية (Process) هي برنامج قيد التنفيذ، تشمل الكود والبيانات والمكدس وعداد البرنامج.","❌ خاطئ. التعليمة الواحدة جزء من البرنامج وليست عملية.","❌ خاطئ. طلب استدعاء النظام آلية اتصال وليس عملية.","❌ خاطئ. تقنية إدارة الذاكرة شيء مختلف عن العملية."]
D[62]=["❌ خاطئ. Ready حالة فعلية - العملية جاهزة للتنفيذ.","❌ خاطئ. Running حالة فعلية - العملية تُنفذ حالياً.","❌ خاطئ. Terminated حالة فعلية - العملية انتهت.","✅ صحيح! Queued ليست حالة قياسية للعمليات. الحالات القياسية هي: New, Ready, Running, Waiting, Terminated."]
D[63]=["❌ خاطئ. FCFS تنفذ حسب ترتيب الوصول وليس أقصر وقت.","✅ صحيح! SJN (أقصر عمل أولاً) تختار العملية ذات أقصر وقت تنفيذ (Burst Time) وتنفذها أولاً.","❌ خاطئ. Round Robin تعطي شرائح زمنية متساوية.","❌ خاطئ. Priority Scheduling تعتمد على الأولوية وليس وقت التنفيذ."]
D[64]=["❌ خاطئ. جدولة الأولوية قد تسبب مجاعة للعمليات منخفضة الأولوية.","❌ خاطئ. SJN قد تسبب مجاعة للعمليات الطويلة.","✅ صحيح! Round Robin تمنع المجاعة لأنها تعطي كل عملية شريحة زمنية متساوية، فلا تُحرم أي عملية من المعالج.","❌ خاطئ. FCFS لا تسبب مجاعة لكنها تعاني من تأثير القافلة."]
D[65]=["❌ خاطئ. لإنهاء عملية نستخدم exit() أو kill().","✅ صحيح! fork() ينشئ عملية جديدة (ابن) نسخة من العملية الأصلية (الأب) في UNIX.","❌ خاطئ. تخصيص الذاكرة يتم عبر malloc() وليس fork().","❌ خاطئ. لتنفيذ أمر جديد نستخدم exec() بعد fork()."]
D[66]=["✅ صحيح! الترحيل (Paging) يسمح بتخصيص ذاكرة غير متجاورة للعمليات عبر تقسيمها إلى صفحات.","❌ خاطئ. التخصيص المتجاور يعطي كتلة واحدة متصلة بالتعريف.","❌ خاطئ. التبديل (Swapping) ينقل العملية كاملة وليس أجزاء منها.","❌ خاطئ. التجزئة مشكلة وليست تقنية تخصيص."]
D[67]=["✅ صحيح! التخصيص المتجاور يسبب تجزئة خارجية (External Fragmentation) بسبب الفراغات بين الكتل المخصصة.","❌ خاطئ. مجاعة العمليات مشكلة جدولة وليست مشكلة تخصيص ذاكرة.","❌ خاطئ. الجمود مشكلة تزامن وليست مشكلة تخصيص ذاكرة.","❌ خاطئ. أخطاء الصفحات مشكلة ذاكرة افتراضية وليست تخصيص متجاور."]
D[68]=["❌ خاطئ. الترحيل تقنية إدارة ذاكرة فعلاً.","❌ خاطئ. التقسيم تقنية إدارة ذاكرة فعلاً.","✅ صحيح! جدولة المعالج (CPU Scheduling) ليست تقنية إدارة ذاكرة بل تقنية إدارة العمليات.","❌ خاطئ. التبديل تقنية إدارة ذاكرة فعلاً."]
D[69]=["❌ خاطئ. الذاكرة الافتراضية لا تزيد حجم RAM الفعلي بل تحاكي ذاكرة أكبر.","✅ صحيح! الذاكرة الافتراضية تسمح بتنفيذ برامج أكبر من الذاكرة الفيزيائية عبر استخدام القرص كامتداد.","❌ خاطئ. تقليل حمل المعالج ليس الغرض الرئيسي.","❌ خاطئ. الذاكرة الافتراضية تزيد استخدام القرص ولا تنقصه."]
D[70]=["❌ خاطئ. قلة استغلال المعالج قد تكون نتيجة للتخبط وليس سببه.","✅ صحيح! التخبط يحدث عندما تحدث أخطاء صفحات بتكرار عالٍ فيقضي النظام معظم وقته في تبديل الصفحات.","❌ خاطئ. تنفيذ العمليات بدون انتظار حالة طبيعية.","❌ خاطئ. زيادة حجم RAM تقلل التخبط ولا تسببه."]
D[71]=["❌ خاطئ. ext4 نظام ملفات Linux.","✅ صحيح! NTFS (New Technology File System) هو نظام الملفات الرئيسي المستخدم في أنظمة Windows.","❌ خاطئ. HFS+ نظام ملفات macOS القديم.","❌ خاطئ. ZFS نظام ملفات متقدم يُستخدم في Solaris وFreeBSD."]
D[72]=["❌ خاطئ. إدارة صلاحيات المستخدمين من وظائف نظام الأمان.","✅ صحيح! الدليل (Directory) يُستخدم لتخزين البيانات الوصفية عن الملفات مثل الاسم والموقع والحجم.","❌ خاطئ. التحكم ببرامج التعريف من وظائف مدير الأجهزة.","❌ خاطئ. تخصيص الذاكرة من وظائف مدير الذاكرة."]
D[73]=["❌ خاطئ. الامتداد لا يحدد اسم الملف.","❌ خاطئ. الامتداد لا يحدد حجم الملف.","✅ صحيح! امتداد الملف يحدد نوع الملف والبرنامج المرتبط به (مثل .txt للنصوص و.exe للتنفيذ).","❌ خاطئ. الامتداد لا يخصص مساحة القرص."]
D[74]=["❌ خاطئ. التخصيص المتجاور يعاني من التجزئة الخارجية.","❌ خاطئ. التخصيص المتصل يعاني من بطء الوصول العشوائي.","✅ صحيح! التخصيص المفهرس (Indexed) يقلل التجزئة باستخدام كتلة فهرس تشير لجميع كتل الملف.","❌ خاطئ. التعيين المباشر ليس طريقة تخصيص ملفات قياسية."]
D[75]=["✅ صحيح! الـ inode يخزن صلاحيات الملف وحجمه والبيانات الوصفية ومواقع كتل البيانات على القرص.","❌ خاطئ. زيادة سرعة التخزين ليست وظيفة الـ inode.","❌ خاطئ. جدولة القرص من وظائف مجدول I/O.","❌ خاطئ. تشفير الملفات ليس من وظائف الـ inode."]
D[76]=["✅ صحيح! الشروط الأربعة للجمود: الاستبعاد المتبادل، الاحتفاظ والانتظار، عدم الاستباق، والانتظار الدائري.","❌ خاطئ. هذه مفاهيم مختلفة وليست شروط الجمود.","❌ خاطئ. هذه مفاهيم مختلفة لا تمثل شروط الجمود.","❌ خاطئ. هذه مفاهيم متنوعة وليست شروط الجمود."]
D[77]=["✅ صحيح! يمكن منع الجمود بتجنب الانتظار الدائري (Circular Wait) عبر ترتيب طلب الموارد.","❌ خاطئ. السماح بالاحتفاظ بعدة موارد يزيد احتمالية الجمود.","❌ خاطئ. زيادة أولوية الجدولة لا تمنع الجمود.","❌ خاطئ. الترحيل تقنية ذاكرة وليست لمنع الجمود."]
D[78]=["✅ صحيح! رسم تخصيص الموارد (RAG) يساعد في تحديد الانتظار الدائري الذي يدل على وجود جمود.","❌ خاطئ. RAG لا يحسن كفاءة نظام الملفات.","❌ خاطئ. RAG ليس لجدولة العمليات.","❌ خاطئ. RAG ليس لتخصيص الذاكرة."]
D[79]=["❌ جزئياً صحيح - المنع إحدى التقنيات فقط.","❌ جزئياً صحيح - التجنب إحدى التقنيات فقط.","❌ جزئياً صحيح - الكشف والاستعادة إحدى التقنيات فقط.","✅ صحيح! جميع التقنيات المذكورة (المنع، التجنب، الكشف والاستعادة) تُستخدم للتعامل مع الجمود."]
D[80]=["✅ صحيح! خوارزمية المصرفي (Banker's Algorithm) تُستخدم لتجنب الجمود عبر التحقق من أن النظام في حالة آمنة قبل تخصيص الموارد.","❌ خاطئ. جدولة المعالج تستخدم خوارزميات أخرى مثل RR وSJN.","❌ خاطئ. جدولة القرص تستخدم FCFS وSSTF وSCAN.","❌ خاطئ. تخصيص الذاكرة يستخدم First Fit وBest Fit."]
D[81]=["❌ خاطئ. لوحة المفاتيح جهاز محرفي (Character device). يكون صحيحاً عند السؤال عن أجهزة المحارف.","❌ خاطئ. الطابعة عادة جهاز محرفي.","✅ صحيح! القرص الصلب جهاز كتلي (Block device) لأنه يقرأ ويكتب البيانات في كتل.","❌ خاطئ. الفأرة جهاز محرفي."]
D[82]=["✅ صحيح! التخزين المؤقت (Spooling) يزيد كفاءة عمليات I/O بتخزين البيانات مؤقتاً (مثل طابور الطباعة).","❌ خاطئ. Spooling لا يدير جدولة المعالج.","❌ خاطئ. Spooling لا يقلل تجزئة الذاكرة.","❌ خاطئ. Spooling لا يمنع الجمود."]
D[83]=["❌ خاطئ. FCFS تخدم الطلبات حسب ترتيب وصولها وليس الأقرب.","✅ صحيح! SSTF (أقصر وقت بحث أولاً) تختار الطلب الأقرب لموقع الرأس الحالي فتقلل وقت البحث.","❌ خاطئ. Round Robin خوارزمية جدولة عمليات وليست جدولة أقراص.","❌ خاطئ. LRU خوارزمية استبدال صفحات وليست جدولة أقراص."]
D[84]=["❌ خاطئ. القرص الصلب جهاز كتلي يقرأ كتلاً من البيانات.","❌ خاطئ. SSD جهاز كتلي.","❌ خاطئ. الطابعة قد تكون محرفية لكن ليست الجواب هنا.","✅ صحيح! لوحة المفاتيح جهاز محرفي (Character device) لأنها ترسل البيانات محرفاً بمحرف."]
D[85]=["✅ صحيح! DMA يسمح للأجهزة بنقل البيانات مباشرة من/إلى الذاكرة بدون تدخل المعالج، مما يحرره لمهام أخرى.","❌ خاطئ. DMA لا يحسن جدولة المعالج.","❌ خاطئ. DMA لا يحسن أداء نظام الملفات مباشرة.","❌ خاطئ. DMA لا يكشف الجمود."]
D[86]=["✅ صحيح! الهدف الرئيسي لأمن نظام التشغيل هو منع الوصول غير المصرح به لحماية البيانات والموارد.","❌ خاطئ. تحسين أداء المعالج ليس من أهداف الأمن.","❌ خاطئ. تقليل تجزئة الذاكرة من وظائف إدارة الذاكرة.","❌ خاطئ. زيادة كفاءة الجدولة من وظائف المجدول."]
D[87]=["✅ صحيح! جدار الحماية (Firewall) يمنع الوصول غير المصرح به للشبكة بفلترة حركة البيانات.","❌ خاطئ. جدولة المعالج ليست من وظائف جدار الحماية.","❌ خاطئ. منع أخطاء الصفحات من وظائف إدارة الذاكرة.","❌ خاطئ. تخصيص الذاكرة ليس من وظائف جدار الحماية."]
D[88]=["❌ خاطئ. FCFS تنفذ حسب ترتيب الوصول بدون شرائح زمنية.","❌ خاطئ. SJN تنفذ الأقصر أولاً بدون شرائح زمنية.","✅ صحيح! Round Robin تعطي كل عملية شريحة زمنية ثابتة (Time Quantum) ثم تنتقل للتالية في طابور دائري.","❌ خاطئ. Priority Scheduling تعتمد على الأولوية وليس شرائح زمنية."]
D[89]=["✅ صحيح! في الجدولة الاستباقية، يمكن مقاطعة العملية الجارية ونقلها لطابور الاستعداد لتنفيذ عملية أخرى ذات أولوية أعلى.","❌ خاطئ. هذا وصف الجدولة غير الاستباقية (Non-preemptive).","❌ خاطئ. الأولوية قابلة للتغيير وليست دائمة.","❌ خاطئ. العملية لا تُمنع من المعالج بل تُقاطع مؤقتاً."]
D[90]=["❌ خاطئ. Round Robin للأغراض العامة وليس حصرياً للوقت الحقيقي.","❌ خاطئ. SRTF جيدة لتقليل وقت الانتظار لكنها ليست الأنسب لأنظمة الوقت الحقيقي.","✅ صحيح! EDF (أقرب موعد نهائي أولاً) مصممة خصيصاً لأنظمة الوقت الحقيقي حيث تعطي الأولوية للمهام ذات المواعيد الأقرب.","❌ خاطئ. Multilevel Feedback Queue للأغراض العامة."]

with open(os.path.join(SD,'os_quiz.html'),'r',encoding='utf-8') as f: c=f.read()
for qid,exps in D.items():
    old_exps = []
    q = None
    with open(os.path.join(SD,'questions.json'),'r',encoding='utf-8') as f:
        qs = json.load(f)
        q = next((x for x in qs if x['id']==qid),None)
    if not q: continue
    ci = next((i for i,o in enumerate(q['options']) if o['correct']),0)
    ct = q['options'][ci]['text']
    # Build old generic explanations
    old_items = []
    for i,o in enumerate(q['options']):
        if o['correct']:
            old_items.append(f"'✅ <b>صحيح.</b> هذا هو الجواب الصحيح حسب بنك الأسئلة.'")
        else:
            t = ct.replace("'","\\'")
            old_items.append(f"'❌ <b>خاطئ.</b> الجواب الصحيح هو: {t}'")
    old_str = f"{qid}:[" + ",".join(old_items) + "]"
    new_items = [f"'{e.replace(chr(39),chr(92)+chr(39))}'" for e in exps]
    new_str = f"{qid}:[" + ",".join(new_items) + "]"
    c = c.replace(old_str, new_str)
with open(os.path.join(SD,'os_quiz.html'),'w',encoding='utf-8') as f: f.write(c)
print(f"Updated {len(D)} questions with detailed explanations (31-90)")
